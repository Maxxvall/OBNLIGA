# План оптимизаций фронтенда

Документ описывает безопасные, поэтапные действия для внедрения рекомендаций по повышению производительности без изменения бизнес-логики.

## 1. Умное кеширование компонентов
- Провести ревизию тяжёлых страниц (`LeaguePage`, `MatchDetailsPage`, `TeamView`, `LeagueTableView`, `LeagueRoundsView` и аналогичных) внутри `frontend/src/components` и `frontend/src/pages`.
- Для каждой компоненты:
  - Убедиться, что `props` передаются через интерфейсы и не пересоздаются без необходимости.
  - Завернуть экспорт в `React.memo` (например, `export default React.memo(LeaguePage);`). При необходимости указать `displayName` и собственную функцию сравнения (`(prev, next) => prev.someField === next.someField`).
  - Проверить, что локальные стейты и эффекты не зависят от объектов, которые меняются без причины; в противном случае стабилизировать их через `useMemo`/`useCallback` перед оборачиванием.
- После изменений прогонять сборку `npm run build` и ручную проверку страниц через `npm run dev`, чтобы убедиться, что поведение идентично исходному и нет лишних ререндеров.

## 2. Асинхронные записи в `localStorage`
- Открыть `frontend/src/store/appStore.ts` и найти участки, где корзина или другие данные синхронно пишутся в `localStorage` (около строк 3157–3158).
- Вынести логику записи в отдельную функцию `writeCartToStorage(cart)`.
- Добавить дебаунс-помощник, например:
  ```ts
  const debouncedWriteCart = debounce((cart) => {
    requestIdleCallback(() => writeCartToStorage(cart));
  }, 400);
  ```
  (Обеспечить полифил `requestIdleCallback` для браузеров, где его нет, либо fallback на `setTimeout` в 200 мс.)
- Обновить все места, где корзина меняется, чтобы вызывать `debouncedWriteCart(cartState)`.
- В README/документации (если нужно) зафиксировать, что сохранение теперь асинхронное, чтобы подтвердить отсутствие регресса на стороне UX.

## 3. Ускоренная загрузка данных матча
### 3.1 Параллельный fetch критичных данных
- В `frontend/src/store/appStore.ts` (блок около 2170–2183) найти последовательные `await fetchHeader(); await fetchLineups(); …`.
- Переписать загрузку заголовка и составов на `Promise.all` внутри одной функции `loadMatchBasics(matchId)`; сохранять результат сразу в грида, чтобы UI не ждал второй запроса.
- Стратегию «предзагрузи всё, а затем лениво» применить для `stats`, `events`, `broadcast`, `comments`: сделать отдельные `lazy`-функции, которые вызываются по переключению табов, и показывать skeleton, пока данные подтягиваются.

### 3.2 Backend batch-endpoint
- На сервере (`backend/src/routes` или в соответствующем сервисе) создать новый маршрут `/api/matches/:id/full`:
  - Собрать те же сущности, которые нужны на странице матча (header, lineups, stats, events, broadcast, comments).
  - Использовать существующие сервисы/кэш, чтобы не нарушить текущую логику.
  - Добавить поддержку `ETag` и `304 Not Modified`, чтобы сохранялась мультиуровневая стратегия кэширования.
  - Если полный payload тяжёл, вернуть `links` на lazy-части, а не всё подряд, чтобы не нарушать бизнес.
- Клиент: добавить метод `fetchMatchFull(matchId)` и в `loadMatchBasics` проверять, доступен ли полный ответ; fallback — `Promise.all` локальных запросов.
- Убедиться, что Unit тесты/типизация и `npm run lint` проходят.

## 4. Улучшение TTL для редко меняющихся данных
- В `frontend/src/store/appStore.ts` (строки 124–137) проанализировать константы TTL (`SEASONS_TTL`, `TABLE_TTL`, `SHOP_ITEMS_TTL`).
- Обновить значения:
  - `SEASONS_TTL` → 10 минут.
  - `SHOP_ITEMS_TTL` → 10 минут.
  - При необходимости оставить `TABLE_TTL` в 1 минуте и задокументировать причины.
- Привести изменения в соответствие с `docs/cache.md`, чтобы не нарушить описанную мультиуровневую стратегию.
- Проверить, что новые значения не создают нежелательных stale-данных, и мониторить поведение после релиза.

## 5. Сжатие статических файлов
- Проверить `frontend/public/_headers` и добавить блок для корня `/*`:
  ```
  /*
    Cache-Control: public, max-age=31536000, immutable
    Content-Encoding: br
  ```
  (Если используется gzip — добавить соответствующий `Content-Encoding: gzip`.)
- Убедиться, что Vite/Render не переопределяют эти заголовки, и при деплое статические файлы отдаются с сжатием.
- При необходимости обновить `render.yaml`, чтобы указать `gzip`/`brotli` compression (если там описываются заголовки) и не нарушить текущую infrastructure-as-code конфигурацию.

## Контрольные точки
- После правок запускать `npm run lint`, `npm run build`, `npm run test` (если есть), и проверять UI страницами, указанными в плане.
- Описание изменений фиксировать на русском языке в `audit/changes/<PR_ID>.md` и в сообщении коммита.
- Объяснение сделанных правок (какую логику и зачем меняли) — кратко и по-русски в итоговых комментариях и документах.
