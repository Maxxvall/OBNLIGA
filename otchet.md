# Отчёт

## Оценка плана: 85/100
- Цель перейти на httpOnly cookie и credentials-only запросы снижает число preflight и превращает каждое API-вызов в простой CORS-запрос, то есть перестанет нагружать backend и CDN лишними OPTIONS.
- Перенос аутентификации в App.tsx и кеширование профиля до рендера вкладок улучшит UX и снизит пиковые нагрузки на базу и redis-слой, потому что запросы к `/api/auth/me` будут делаться только при реальной смене контекста.
- Использование WebSocket/реaltime-каналов для фоновых обновлений выглядит разумно, если их авторизация продолжит использовать существующие токены (в идеале — httpOnly cookie).

## Возможные улучшения
1. **Стабилизировать кеш профиля через redis/`defaultCache`.** Сейчас сервер уже использует `defaultCache` + ETag (см. `authRoutes.ts`), так что можно в план включить бизнес-кейс: передавать ETag в App при загрузке и обновлять только при необходимости, чтобы сократить обращения к базе и redis. Это особенно важно для вкладок, где прокрутка не меняет пользователя, но сейчас каждая монтировка `Profile` потенциально запускает `loadProfile`.
2. **Привязать WebSocket к session cookie.** У сервера (`realtime/index.ts`) уже есть валидатор, но он ищет куки `auth_token`. Предлагаю дополнительно разрешить `session` и/или `sec-websocket-protocol`, тогда клиент сможет обращаться к redis-каналам без чтения `localStorage` и без передачи Authorization, что экономит память клиента и ускоряет handshakes.
3. **Сделать план на дев-среду более детальным.** Если Telegram init не сработал, стоит предусмотреть явную кнопку переработки (manual refresh) и контролируемый fallback (например, отдельный dev payload с `initData`), чтобы не дергать сервер и redis лишними авторизациями при каждой перезагрузке страницы.

Все предложения направлены на минимизацию обращений к CPU/RAM сервера, сокращение количества операций с базой и тем самым повышают общую пропускную способность.
