**Сравнение логики "Streak" (старый проект) и текущей реализацией достижений**

Коротко — только факты и рекомендации.

1) Что было в старом проекте (`check.md`) — лучшие моменты
- Чёткие tier-пороги: [7, 30, 120] для bronze/silver/gold — простая и понятная модель.
- Хранение серии в пользователе: `users.consecutive_days` + `last_checkin_date` — быстрый доступ и простая проверка состояния.
- Идемпотентная выдача наград: таблица `user_achievement_rewards` с уникальным индексом (user_id, group, tier) — надёжно предотвращает дубли.
- Batch-награждение: собираются unlocked_events → проверка idempotency → накопление total_xp/credits → одно обновление пользователя — экономно и атомарно.
- Monotonic guard: защита от понижения XP/уровня при рассинхронах — полезно для консистентности профилей.
- UI/ETag/кэш: `/api/achievements` использует кэш с ETag — уменьшает нагрузку.

2) Что есть в текущем проекте (по коду репо)
- Модели Prisma: `AchievementType`, `AchievementLevel`, `UserAchievementProgress`, `UserAchievement`.
- Два подхода: прогресс-ориентированные (levels + userAchievementProgress + incrementAchievementProgress) и пороговые (direct userAchievement в `matchAggregation`).
- `incrementAchievementProgress(userId, metric, delta, client)` — центральная функция для прогресса и разблокировки уровней.
- `claimDailyReward` вызывает `incrementAchievementProgress(..., AchievementMetric.DAILY_LOGIN, 1, tx)` — интеграция чекинов с прогрессом.
- Админка: CRUD для типов достижений; `recomputeAchievementsForType(achievementTypeId)` — массовый пересчёт.
- Фронтенд: SWR-кеширование, API `GET /api/users/me/achievements`, профиль рендерит уровни и прогресс.

3) Сравнение — что взять из старого проекта (лучшее) в текущий
- Idempotency таблица `user_achievement_rewards`: добавить/поддерживать для каждого выдаваемого бонуса (если текущий проект выдаёт очки/кредиты при разблокировке уровня). Это гарантирует ровно одно начисление.
- Batch-выдачу наград: собирать unlocked events и применять одно агрегированное обновление (как в `check.md`) — уменьшит число транзакций и гонок при массовом апдейте.
- Monotonic guard: сохранить политику, чтобы избежать понижения XP/уровней при ошибках записи.
- ETag/кэш и SWR: оставить/усилить (у текущего проекта уже есть поддержка) — важно для снижения нагрузки на API.

4) Минусы старого подхода и как их улучшить (оптимизация для сервера/БД/Redis)
- Проблема: запись `users.consecutive_days` и конкурентный `POST /api/checkin` могут привести к гонкам.
  - Улучшение: использовать транзакции с `SELECT ... FOR UPDATE` на строке пользователя при обновлении streak, либо Redis-based distributed lock (SETNX с TTL) перед апдейтом. Если нагрузка очень высокая — лучше атомарно инкрементировать в Redis и периодически синхронизировать в БД.
- Проблема: долгие транзакции при одновременной выдаче наград (включая расчёт уровня и запись reward-логов).
  - Улучшение: разделить операции: 1) быстрый апдейт прогресса + флаг о разблокировке; 2) публиковать задачу в очередь (Redis/Bull) для обработки наград (создание записей `user_achievement_rewards` и финального начисления дней). Это снизит latency пользовательского запроса.
- Проблема: полный скан пользователей в `recomputeAchievementsForType` (админский PUT вызывает перебор всех пользователей) — не масштабируется. - нужно решить эту проблему для маштабируемости в будущем.
  - Улучшение: вычислять набор пользователей через SQL (WHERE условия) — например, для `TOTAL_PREDICTIONS` выполнить запросы с агрегацией, чтобы выбрать только тех, кто соответствует порогу и ещё не имеет записи `user_achievement`. Или запускать процесс постранично/в фоне вместо одного монолитного цикла.
- Проблема: хранение `consecutive_days` в основной таблице `users` делает hot-row при массовом чекине.
  - Улучшение: использовать Redis counter per-user (ключ `streak:{userId}`) с ежедневным TTL/сбросом и синхронизацией в БД в off-peak или при важных событиях; либо sharding/partitioning по user_id чтобы снизить contention.
- Проблема: если награды выдаются синхронно, возможны частичные успешные состояния при ошибке (например, tiers обновились, а начисление очков нет).
  - Улучшение: использовать транзакцию для критичных обновлений, или применять шаги: пометить unlocked + записать idempotency-row, затем попытаться начислить и логировать ошибки, при неудаче ретраить через очередь; приоритет — не допускать двойного начисления.

5) Рекомендации по архитектуре (конкретно: сервер, БД, Redis, очередь)
- БД (Postgres):
  - Убедиться в единственном индексе/уникальности для `user_achievement_rewards(user_id, group, tier)`.
  - Для апдейта streak использовать `SELECT FOR UPDATE` или отдельную таблицу `user_streaks(user_id PK, consecutive_days, last_checkin_date)` чтобы уменьшить impact на `users` row.
  - Для массовых пересчётов использовать set-based SQL (JOIN / aggregate) вместо чтения всех пользователей в приложение.

- Redis / Locking:
  - Для защиты от гонок на `POST /checkin` использовать `SETNX lock:checkin:{userId}` с коротким TTL; или Redis lua-скрипт, который проверяет и инкрементит в одном атомарном шаге.
  - Для высоких нагрузок держать актуальный streak в Redis (atomic INCR/EXPIRE), и периодически синкать в БД (например, каждые N минут или при достижении важного события).

- Очереди и фоновые воркеры (использовать только бесплатные сервисы на render.com пока поток клиентов невелик до 100/день):
  - Переместить тяжёлую работу (создание reward-логов, пересчёт рейтингов, пересчёт achievement-видов на всех пользователях) в фоновые задачи (BullMQ/Redis, RabbitMQ, или серверless job). HTTP-ручки ставят задачи и возвращают ответ быстро.
  - Обновления, требующие консистентности, делать в транзакции в воркере: upsert idempotency-row → начисление очков → подтверждение.

- Кэширование и API:
  - Поддерживать ETag/версионирование для `/api/achievements` (как в старом проекте и текущем — хорошо). Инвалидировать кеши после асинхронного начисления.

6) Конкретные мелкие улучшения/советы по реализации в текущем проекте
- Добавить таблицу `user_achievement_rewards` (если не нужна отдельная) или расширить `user_achievement`/`userAchievementProgress` схемой логов, чтобы хранить факт конкретного начисления (idempotency).
- В `incrementAchievementProgress` при обнаружении нового уровня: не выполнять тяжёлые наградные записи синхронно в основном запросе — помечать и пушить задачу на воркер.
- В `recomputeAchievementsForType` использовать SQL-выборку: SELECT app_user.id FROM app_user LEFT JOIN user_achievement ON ... WHERE условие AND user_achievement.user_id IS NULL; затем batch-create вместо загрузки всех пользователей в память.
- Мониторинг: добавить метрики (Prometheus) на частоту чек-инов, количество разблокировок, ошибок выдачи наград, очередь задач; алерты на рост ошибок начислений.

7) Итог (коротко по факту)
- Берём из старого проекта: понятные tier'ы, idempotency-лог (`user_achievement_rewards`), batch-выдачу наград, monotonic guard, ETag-кэширование.
- Добавляем/интегрируем в текущий проект: Redis locking/atomic ops для чекинов, фоновые воркеры для начислений, SQL-driven bulk recompute, и аккуратную инвалидацию кешей.

Если хотите, могу:
- 1) предложить конкретную схему для `user_achievement_rewards` и миграцию Prisma; 
- 2) подготовить пример Redis-lua скрипта для атомарного чек-ина; 
- 3) написать пример воркера на Node/TS (BullMQ) для безопасного начисления наград.

Файл составлен на основе `check.md` (прошлого проекта) и текущей кодовой базы (`prisma`, `backend/src/services`, `backend/src/routes`).
